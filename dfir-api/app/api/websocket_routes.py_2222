# app/api/websocket_routes.py

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends
from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.database import get_db
from app.models.action_job_detail import ActionJobDetail
import json
import asyncio

router = APIRouter()

@router.websocket("/investigations/nkase/logs")
async def websocket_malware_logs(
    websocket: WebSocket,
    db: AsyncSession = Depends(get_db)
):
    await websocket.accept()
    
    try:
        # Get case number from query string
        case_number = websocket.query_params.get("case_number")
        if not case_number:
            await websocket.send_text(json.dumps({"error": "Missing case_number query parameter"}))
            await websocket.close()
            return

        last_id = None

        while True:
            stmt = (
                select(ActionJobDetail)
                .where(ActionJobDetail.case_number == case_number)
                .order_by(ActionJobDetail.timestamp)
            )
            result = await db.execute(stmt)
            logs = result.scalars().all()

            # Filter only new logs
            new_logs = [log for log in logs if last_id is None or log.id > last_id]
            if new_logs:
                for log in new_logs:
                    await websocket.send_text(json.dumps({
                        "id": log.id,
                        "job_id": str(log.job_id),
                        "instance_id": log.instance_id,
                        "snapshot_id": log.snapshot_id,
                        "tenat_progress": log.tenat_progress,
                        "volume_id": log.volume_id,
                        "nkase_snapshot_id": log.nkase_snapshot_id,
                        "nkase_snapshot_progress": log.nkase_snapshot_progress,
                        "nkase_volume_id": log.nkase_volume_id,
                        "action": log.action,
                        "status": log.status,
                        "stage": log.stage,
                        "message": log.message,
                        "details": log.details,
                        "timestamp": log.timestamp.isoformat() if log.timestamp else None,
                        "case_number": log.case_number,
                        "account_id": log.account_id,
                        "errors": log.errors
                    }))
                    # Stop fetching if the log matches the stop condition
                    if log.case_number == case_number and log.stage == "nkase volume attached":
                        # Call SSM send_command for ClamAV scan
                        import boto3
                        ssm_client = boto3.client('ssm', region_name='us-east-1')
                        instance_id = log.instance_id
                        logpath = log.case_number
                        logpath = f"{instance_id}_{log.nkase_volume_id}.log"
                        EBSAttachedDevicePath = log.details.get('device') if log.details else None
                        if instance_id and logpath and EBSAttachedDevicePath:
                            try:
                                calmScanCmd = ssm_client.send_command(
                                    InstanceIds=[instance_id],
                                    DocumentName='AWS-RunShellScript',
                                    Parameters={'commands': [f"sudo sh /root/scripts/invokeclamscan.sh {logpath} {EBSAttachedDevicePath}"]},
                                    Comment='calling clam scan script'
                                )
                                print(f"[WebSocket] ClamAV scan command sent: {calmScanCmd}")
                            except Exception as ssm_ex:
                                print(f"[WebSocket] Failed to send ClamAV scan command: {ssm_ex}")
                        else:
                            print(f"[WebSocket] Missing instance_id, logpath, or device for ClamAV scan command.")
                        await websocket.close()
                        return
                last_id = new_logs[-1].id
            

            await asyncio.sleep(2)
            

    except WebSocketDisconnect:
        print(f"[WebSocket] Client disconnected for case_number={case_number}")
    except Exception as e:
        await websocket.send_text(json.dumps({"error": str(e)}))
        await websocket.close()


##'Device': '/dev/sdf', 'State': 'attached'
